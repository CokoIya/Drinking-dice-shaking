<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>喝酒摇骰子 · 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      height: 100vh;
      background: radial-gradient(circle at top, #1c283d 0, #050816 45%, #000 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
        sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }
    header {
      padding: 10px 0 4px;
      font-size: 18px;
      font-weight: 600;
    }
    #app {
      position: relative;
      flex: 1;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #stage {
      position: relative;
      width: min(520px, 100vw);
      height: min(520px, 65vh);
      touch-action: none;
    }
    #three-container {
      width: 100%;
      height: 100%;
    }
    /* 设置按钮（右下角） */
    #settings-btn {
      position: absolute;
      bottom: 18px;
      right: 18px;
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      color: #ffd54f;
      font-size: 18px;
      cursor: pointer;
      z-index: 11;
    }
    /* 历史记录 */
    #history-panel {
      width: 100%;
      max-width: 560px;
      padding: 6px 12px 10px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.4));
      font-size: 12px;
      max-height: 35vh;
      overflow-y: auto;
    }
    #history-panel .title {
      font-size: 13px;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    #history-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #history-list li {
      padding: 2px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
    #history-list span.time {
      opacity: 0.6;
      margin-right: 6px;
    }
    /* 设置面板 */
    #settings-panel {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.55);
      z-index: 100;
    }
    #settings-panel.hidden {
      display: none;
    }
    .settings-inner {
      width: 260px;
      padding: 16px 18px;
      border-radius: 10px;
      background: #222;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
    }
    .settings-inner h2 {
      margin: 0 0 10px;
      font-size: 16px;
    }
    .settings-inner label {
      display: block;
      margin-bottom: 10px;
      font-size: 14px;
    }
    .settings-inner input[type="number"] {
      width: 80px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #fff;
    }
    .settings-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 6px;
    }
    .settings-actions button {
      padding: 4px 10px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 13px;
    }
    #save-settings {
      background: #ffd54f;
      color: #222;
    }
    #close-settings {
      background: #444;
      color: #fff;
    }
  </style>
</head>
<body>
<header>喝酒摇骰子 · 3D</header>

<div id="app">
  <div id="stage">
    <div id="three-container"></div>
    <button id="settings-btn">⚙️</button>
  </div>
</div>

<div id="history-panel">
  <div class="title">历史记录（最新在上，保留最近 20 次）</div>
  <ul id="history-list"></ul>
</div>

<!-- 设置弹窗 -->
<div id="settings-panel" class="hidden">
  <div class="settings-inner">
    <h2>设置</h2>
    <label>
      骰子个数（3 - 10）：
      <input id="dice-count-input" type="number" min="3" max="10" />
    </label>
    <div style="font-size: 12px; opacity: 0.7;">
      提示：骰子个数会写入 Cookie，刷新页面会保留。
    </div>
    <div class="settings-actions">
      <button id="close-settings">取消</button>
      <button id="save-settings">保存</button>
    </div>
  </div>
</div>

<!-- 音效：dice-shake.mp3 放在同一目录 -->
<audio id="dice-sound" src="dice-shake.mp3" preload="auto"></audio>

<script>
  // ---------- Cookie ----------
  function getCookie(name) {
    const value = "; " + document.cookie;
    const parts = value.split("; " + name + "=");
    if (parts.length === 2) return parts.pop().split(";").shift();
    return null;
  }
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
    document.cookie =
      name + "=" + value + ";expires=" + d.toUTCString() + ";path=/";
  }

  const DICE_HISTORY_KEY = "diceHistory";
  const DICE_COUNT_KEY = "diceCount";

  // ---------- DOM ----------
  const container = document.getElementById("three-container");
  const stage = document.getElementById("stage");
  const settingsBtn = document.getElementById("settings-btn");
  const settingsPanel = document.getElementById("settings-panel");
  const diceCountInput = document.getElementById("dice-count-input");
  const saveSettingsBtn = document.getElementById("save-settings");
  const closeSettingsBtn = document.getElementById("close-settings");
  const diceSound = document.getElementById("dice-sound");
  const historyList = document.getElementById("history-list");

  let diceCount = 5; // 默认数量
  let diceMeshes = [];
  let diceTextures = {}; // 1..6
  let scene, camera, renderer;
  let cupGroup, cupBody, cupTop;
  let plate;

  // 几何尺寸（单位随意但要统一）
  const TABLE_Y = 0;
  const DICE_SIZE = 0.8;
  const CUP_HEIGHT = 4.0;
  const CUP_RADIUS_TOP = 2.0;
  const CUP_RADIUS_BOTTOM = 2.2;

  // 让骰蛊和蓝色盘子紧贴：盘子顶面在 y = TABLE_Y
  // 盖住状态：杯底高度略高于盘子顶面一点点防止闪烁
  const CUP_BOTTOM_CLOSED = TABLE_Y + 0.01;
  const CUP_BOTTOM_OPEN = TABLE_Y + 0.7;  // 半开，刚好露出骰子
  const CUP_BOTTOM_LIFTED = TABLE_Y + 4.0; // 完全抬起

  function bottomToGroupY(bottom) {
    return bottom + CUP_HEIGHT / 2;
  }

  // 杯子状态
  const CUP_STATE = {
    OPEN_TILT: "open_tilt",  // 初始半倾斜
    ROLLING: "rolling",      // 正在摇
    READY: "ready",          // 盖住，等待上滑开
    LIFTED: "lifted"         // 已经打开
  };
  let cupState = CUP_STATE.OPEN_TILT;
  let shakeStart = 0;

  // 手势拖动状态
  let pointerDownX = null;
  let pointerDownY = null;
  let pointerMoved = false;
  let dragMode = null;      // "open" | "close" | null
  let dragStartState = null;
  let dragProgress = 0;     // 0~1
  const DRAG_DISTANCE = 180; // 拖动 180 像素视为 100%

  // 骰子历史保存
  function loadHistoryFromCookie() {
    const raw = getCookie(DICE_HISTORY_KEY);
    if (!raw) return [];
    try {
      return JSON.parse(decodeURIComponent(raw));
    } catch {
      return [];
    }
  }
  function saveHistoryToCookie(values) {
    let history = loadHistoryFromCookie();
    history.push({ time: Date.now(), values });
    if (history.length > 20) {
      history = history.slice(history.length - 20);
    }
    setCookie(
      DICE_HISTORY_KEY,
      encodeURIComponent(JSON.stringify(history)),
      365
    );
    renderHistory(history);
  }
  function renderHistory(history) {
    historyList.innerHTML = "";
    const reversed = [...history].reverse();
    reversed.forEach((item) => {
      const li = document.createElement("li");
      const time = new Date(item.time);
      const timeStr = time.toLocaleTimeString();
      const valuesStr = item.values.join(",");
      li.innerHTML =
        '<span class="time">' +
        timeStr +
        '</span><span class="values">[' +
        valuesStr +
        "]</span>";
      historyList.appendChild(li);
    });
  }

  // ---------- Three.js 初始化 ----------
  function initThree() {
    scene = new THREE.Scene();

    const width = container.clientWidth;
    const height = container.clientHeight;
    camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100);
    camera.position.set(0, 5.5, 10);
    camera.lookAt(0, 1.8, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    // 光照
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(6, 10, 4);
    scene.add(dirLight);
    const hemi = new THREE.HemisphereLight(0xe0e8ff, 0x111122, 0.4);
    scene.add(hemi);

    // 底盘
    const plateGeo = new THREE.CylinderGeometry(2.7, 2.7, 0.3, 64);
    const plateMat = new THREE.MeshStandardMaterial({
      color: 0x275dba,
      roughness: 0.35,
      metalness: 0.25,
    });
    plate = new THREE.Mesh(plateGeo, plateMat);
    plate.position.y = TABLE_Y - 0.15; // 顶面在 TABLE_Y
    scene.add(plate);

    // 地面影子
    const floorGeo = new THREE.CircleGeometry(6.5, 64);
    const floorMat = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
      opacity: 0.45,
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = TABLE_Y - 0.16;
    scene.add(floor);

    // 不锈钢材质
    const cupMat = new THREE.MeshPhysicalMaterial({
      color: 0xd8d8d8,
      metalness: 0.95,
      roughness: 0.2,
      clearcoat: 0.7,
      clearcoatRoughness: 0.2,
      side: THREE.DoubleSide,
    });

    // 圆润杯身（圆柱 + 半球）
    const bodyGeo = new THREE.CylinderGeometry(
      CUP_RADIUS_TOP,
      CUP_RADIUS_BOTTOM,
      CUP_HEIGHT * 0.8,
      72,
      16,
      true
    );
    cupBody = new THREE.Mesh(bodyGeo, cupMat);
    cupBody.position.y = -CUP_HEIGHT * 0.1;

    const topGeo = new THREE.SphereGeometry(
      CUP_RADIUS_TOP,
      64,
      32,
      0,
      Math.PI * 2,
      0,
      Math.PI / 2
    );
    cupTop = new THREE.Mesh(topGeo, cupMat);
    cupTop.position.y = cupBody.position.y + CUP_HEIGHT * 0.4;

    cupGroup = new THREE.Group();
    cupGroup.add(cupBody);
    cupGroup.add(cupTop);
    cupGroup.position.set(0, bottomToGroupY(CUP_BOTTOM_OPEN), 0);
    cupGroup.rotation.x = -0.6; // 初始半倾斜
    scene.add(cupGroup);

    // 骰子纹理 & 网格
    createDiceTextures();
    createDiceMeshes();

    window.addEventListener("resize", onWindowResize);
    animate();
  }

  function onWindowResize() {
    if (!renderer) return;
    const width = container.clientWidth;
    const height = container.clientHeight;
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  }

  // ---------- 画圆角骰子纹理 ----------
  function roundRectPath(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function createDiceTextures() {
    function pipPositions(size) {
      const s = size;
      const r = s * 0.1;
      const off = s * 0.25;
      return {
        center: { x: s / 2, y: s / 2 },
        tl: { x: s / 2 - off, y: s / 2 - off },
        tr: { x: s / 2 + off, y: s / 2 - off },
        bl: { x: s / 2 - off, y: s / 2 + off },
        br: { x: s / 2 + off, y: s / 2 + off },
        ml: { x: s / 2 - off, y: s / 2 },
        mr: { x: s / 2 + off, y: s / 2 },
        r,
      };
    }

    for (let n = 1; n <= 6; n++) {
      const size = 256;
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");

      const grd = ctx.createRadialGradient(
        size * 0.25, size * 0.25, size * 0.1,
        size * 0.8, size * 0.8, size * 0.9
      );
      grd.addColorStop(0, "#ffffff");
      grd.addColorStop(1, "#d0d0d0");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, size, size);

      // 圆角轮廓
      ctx.lineWidth = size * 0.05;
      ctx.strokeStyle = "#a0a0a0";
      ctx.fillStyle = "#fdfdfd";
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = size * 0.05;

      roundRectPath(
        ctx,
        size * 0.08,
        size * 0.08,
        size * 0.84,
        size * 0.84,
        size * 0.18
      );
      ctx.fill();
      ctx.stroke();

      // 点数
      const p = pipPositions(size);
      ctx.fillStyle = "#222";
      ctx.shadowColor = "rgba(0,0,0,0.35)";
      ctx.shadowBlur = size * 0.04;

      function drawDot(pos) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, p.r, 0, Math.PI * 2);
        ctx.fill();
      }

      switch (n) {
        case 1:
          drawDot(p.center); break;
        case 2:
          drawDot(p.tl); drawDot(p.br); break;
        case 3:
          drawDot(p.tl); drawDot(p.center); drawDot(p.br); break;
        case 4:
          drawDot(p.tl); drawDot(p.tr); drawDot(p.bl); drawDot(p.br); break;
        case 5:
          drawDot(p.tl); drawDot(p.tr); drawDot(p.center); drawDot(p.bl); drawDot(p.br); break;
        case 6:
          drawDot(p.tl); drawDot(p.tr); drawDot(p.ml); drawDot(p.mr); drawDot(p.bl); drawDot(p.br); break;
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = 8;
      diceTextures[n] = texture;
    }
  }

  // ---------- 骰子布局，带“碰撞体积” ----------
  function computeDiceLayout(count) {
    const positions = [];
    // 限制在杯子半径之内，预留一点边距避免贴住杯壁
    const maxR = CUP_RADIUS_BOTTOM - DICE_SIZE * 0.7;
    const minDist = DICE_SIZE * 1.3;

    for (let i = 0; i < count; i++) {
      let placed = false;
      for (let tries = 0; tries < 200; tries++) {
        const r = Math.random() * maxR;
        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;

        let ok = true;
        for (let p of positions) {
          const dx = x - p.x;
          const dz = z - p.z;
          if (Math.sqrt(dx * dx + dz * dz) < minDist) {
            ok = false;
            break;
          }
        }
        if (ok) {
          positions.push({ x, z });
          placed = true;
          break;
        }
      }

      if (!placed) {
        // 随机实在放不下时退化为规则网格
        positions.length = 0;
        const cols = Math.ceil(Math.sqrt(count));
        const spacing = DICE_SIZE * 1.4;
        for (let j = 0; j < count; j++) {
          const row = Math.floor(j / cols);
          const col = j % cols;
          positions.push({
            x: (col - (cols - 1) / 2) * spacing,
            z: (row - (cols - 1) / 2) * spacing,
          });
        }
        break;
      }
    }
    return positions;
  }

  function layoutDiceRandom() {
    if (!diceMeshes.length) return;
    const positions = computeDiceLayout(diceCount);
    diceMeshes.forEach((mesh, idx) => {
      const p = positions[idx];
      mesh.position.set(
        p.x,
        TABLE_Y + DICE_SIZE / 2 + 0.02,
        p.z
      );
      // 只绕 y 转，保证上下两个面始终是“面”
      mesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
    });
  }

  // ---------- 创建骰子 ----------
  function createDiceMeshes() {
    diceMeshes.forEach((m) => scene.remove(m));
    diceMeshes = [];

    const diceGeo = new THREE.BoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE, 2, 2, 2);

    const positions = computeDiceLayout(diceCount);

    for (let i = 0; i < diceCount; i++) {
      // 六个面的点数纹理都给上，让侧面也有点数
      const order = [3, 4, 1, 6, 2, 5]; // +x,-x,+y,-y,+z,-z 对应的点数
      const mats = order.map(num => new THREE.MeshStandardMaterial({
        map: diceTextures[num],
        roughness: 0.35,
        metalness: 0.05,
      }));

      const mesh = new THREE.Mesh(diceGeo, mats);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      const p = positions[i];
      mesh.position.set(
        p.x,
        TABLE_Y + DICE_SIZE / 2 + 0.02,
        p.z
      );
      mesh.rotation.set(0, Math.random() * Math.PI * 2, 0);

      scene.add(mesh);
      diceMeshes.push(mesh);
    }
  }

  // 更新骰子点数（修改顶部材质贴图）
  function updateDiceValues(values) {
    diceMeshes.forEach((mesh, idx) => {
      const v = values[idx] || 1;
      const topMat = mesh.material[2]; // +y
      topMat.map = diceTextures[v];
      topMat.needsUpdate = true;
    });
  }

  // ---------- 杯子动画 ----------
  let isRolling = false;
  let hasRolled = false;
  let currentResult = [];

  function startRoll() {
    if (isRolling) return;

    // 新一轮结果
    currentResult = [];
    for (let i = 0; i < diceCount; i++) {
      currentResult.push(Math.floor(Math.random() * 6) + 1);
    }
    layoutDiceRandom();
    updateDiceValues(currentResult);

    isRolling = true;
    hasRolled = false;
    cupState = CUP_STATE.ROLLING;
    shakeStart = performance.now();

    if (diceSound) {
      try {
        diceSound.currentTime = 0;
        diceSound.play().catch(() => {});
      } catch (e) {}
    }
  }

  function updateCupTransform(time) {
    const baseClosedY = bottomToGroupY(CUP_BOTTOM_CLOSED);
    const baseOpenY = bottomToGroupY(CUP_BOTTOM_OPEN);
    const baseLiftedY = bottomToGroupY(CUP_BOTTOM_LIFTED);

    // 拖动时不让自动插值干扰，ROLLING 时除外
    if (isDragging && cupState !== CUP_STATE.ROLLING) {
      return;
    }

    if (cupState === CUP_STATE.OPEN_TILT) {
      cupGroup.position.y += (baseOpenY - cupGroup.position.y) * 0.2;
      cupGroup.rotation.x += (-0.6 - cupGroup.rotation.x) * 0.2;
    } else if (cupState === CUP_STATE.ROLLING) {
      cupGroup.position.y += (baseClosedY - cupGroup.position.y) * 0.25;
      cupGroup.rotation.x += (0 - cupGroup.rotation.x) * 0.25;

      const t = (time - shakeStart) / 1000;
      if (t < 0.5) {
        const shakeAngle = Math.sin(t * Math.PI * 10) * 0.18;
        const shakeOffset = Math.sin(t * Math.PI * 12) * 0.06;
        cupGroup.rotation.z = shakeAngle;
        cupGroup.position.y = baseClosedY + shakeOffset;
      } else {
        cupGroup.rotation.z += (0 - cupGroup.rotation.z) * 0.3;
        cupGroup.position.y += (baseClosedY - cupGroup.position.y) * 0.3;
        cupState = CUP_STATE.READY;
        isRolling = false;
        hasRolled = true;
      }
    } else if (cupState === CUP_STATE.READY) {
      cupGroup.position.y += (baseClosedY - cupGroup.position.y) * 0.2;
      cupGroup.rotation.x += (0 - cupGroup.rotation.x) * 0.2;
      cupGroup.rotation.z += (0 - cupGroup.rotation.z) * 0.2;
    } else if (cupState === CUP_STATE.LIFTED) {
      cupGroup.position.y += (baseLiftedY - cupGroup.position.y) * 0.2;
      cupGroup.rotation.x += (-0.4 - cupGroup.rotation.x) * 0.2;
      cupGroup.rotation.z += (0 - cupGroup.rotation.z) * 0.2;
    }
  }

  function animate(time) {
    requestAnimationFrame(animate);
    if (!scene) return;
    updateCupTransform(time || performance.now());
    renderer.render(scene, camera);
  }

  // ---------- 设置 ----------
  function loadDiceCountFromCookie() {
    const raw = getCookie(DICE_COUNT_KEY);
    if (!raw) return;
    const n = parseInt(raw, 10);
    if (!Number.isNaN(n) && n >= 3 && n <= 10) diceCount = n;
  }
  function openSettings() {
    settingsPanel.classList.remove("hidden");
    diceCountInput.value = diceCount;
  }
  function closeSettings() {
    settingsPanel.classList.add("hidden");
  }

  settingsBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    openSettings();
  });
  closeSettingsBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    closeSettings();
  });
  saveSettingsBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    let val = parseInt(diceCountInput.value, 10);
    if (Number.isNaN(val) || val < 3 || val > 10) {
      alert("请输入 3 - 10 之间的整数");
      return;
    }
    diceCount = val;
    setCookie(DICE_COUNT_KEY, String(diceCount), 365);
    createDiceMeshes();
    closeSettings();
  });
  settingsPanel.addEventListener("click", (e) => {
    if (e.target === settingsPanel) closeSettings();
  });

  // ---------- 手势：点击摇，上滑开，下滑关 ----------
  let isDragging = false;

  stage.addEventListener("pointerdown", (e) => {
    if (e.target.closest("#settings-btn") || e.target.closest("#settings-panel")) {
      return;
    }
    pointerDownX = e.clientX;
    pointerDownY = e.clientY;
    pointerMoved = false;
    dragMode = null;
    dragProgress = 0;
    dragStartState = cupState;
  });

  stage.addEventListener("pointermove", (e) => {
    if (pointerDownY === null) return;
    const dx = e.clientX - pointerDownX;
    const dy = e.clientY - pointerDownY;
    if (Math.abs(dx) > 4 || Math.abs(dy) > 4) pointerMoved = true;

    if (cupState === CUP_STATE.ROLLING) return;

    const baseClosedY = bottomToGroupY(CUP_BOTTOM_CLOSED);
    const baseLiftedY = bottomToGroupY(CUP_BOTTOM_LIFTED);

    if (!dragMode) {
      // 从盖住/初始状态向上滑 = 开
      if ((dragStartState === CUP_STATE.READY || dragStartState === CUP_STATE.OPEN_TILT) && dy < 0) {
        dragMode = "open";
      }
      // 从打开状态向下滑 = 关
      else if (dragStartState === CUP_STATE.LIFTED && dy > 0) {
        dragMode = "close";
      } else {
        return;
      }
    }

    isDragging = true;

    if (dragMode === "open") {
      const raw = -dy / DRAG_DISTANCE;
      dragProgress = Math.max(0, Math.min(1, raw));
      const t = dragProgress;
      cupGroup.position.y = baseClosedY + (baseLiftedY - baseClosedY) * t;
      cupGroup.rotation.x = 0 + (-0.4 - 0) * t;
    } else if (dragMode === "close") {
      const raw = dy / DRAG_DISTANCE;
      dragProgress = Math.max(0, Math.min(1, raw));
      const t = dragProgress;
      cupGroup.position.y = baseLiftedY + (baseClosedY - baseLiftedY) * t;
      cupGroup.rotation.x = -0.4 + (0 - (-0.4)) * t;
    }
    cupGroup.rotation.z = 0;
  });

  function handlePointerEnd(e) {
    if (pointerDownY === null) return;
    const dx = e.clientX - pointerDownX;
    const dy = e.clientY - pointerDownY;
    const tap =
      !pointerMoved || (Math.abs(dx) < 10 && Math.abs(dy) < 10);

    if (tap) {
      // 轻触 = 摇骰子
      startRoll();
    } else if (dragMode === "open") {
      // 松手时 >=50% 继续打开，否则归位
      if (dragProgress >= 0.5) {
        cupState = CUP_STATE.LIFTED;
        if (hasRolled) {
          saveHistoryToCookie(currentResult);
          hasRolled = false;
        }
      } else {
        cupState = CUP_STATE.READY;
      }
    } else if (dragMode === "close") {
      if (dragProgress >= 0.5) {
        cupState = CUP_STATE.READY;
      } else {
        cupState = CUP_STATE.LIFTED;
      }
    }

    pointerDownX = pointerDownY = null;
    pointerMoved = false;
    dragMode = null;
    dragStartState = null;
    dragProgress = 0;
    isDragging = false;
  }

  stage.addEventListener("pointerup", handlePointerEnd);
  stage.addEventListener("pointercancel", handlePointerEnd);

  // ---------- 初始化 ----------
  (function init() {
    loadDiceCountFromCookie();
    initThree();
    cupState = CUP_STATE.OPEN_TILT;
    const history = loadHistoryFromCookie();
    renderHistory(history);
  })();
</script>
</body>
</html>
